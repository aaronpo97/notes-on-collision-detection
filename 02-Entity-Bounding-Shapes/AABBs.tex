\subsection{Axis Aligned Bounding Boxes (AABB)}
In 2D games, objects are often enclosed in rectangles known as bounding boxes.
These are usually the smallest possible rectangle that completely encompasses
the texture's width and height. However, this is not always the case, as some
imperfections may exist such as the entity being larger than the bounding box.

Rectangles can be oriented in any direction as long as all four sides meet at
90-degree angles. This creates complexity in collision detection, requiring
calculations for line-line intersections. To simplify this, we can use
something called an axis-aligned bounding box (AABB). An AABB is a rectangle
that is aligned with the x and y axes, i.e. with sides parallel to the
coordinate axes.

\subsubsection{Point and AABB Intersection}

The simplest calculation for AABBs is to check whether a point is inside the
rectangle. Given a point $p$ and a rectangle with corners $c_1$ and $c_2$, we
can determine if the point is inside the rectangle by checking if the point's x
and y coordinates are within the rectangle's x and y coordinates. This is done
by the following formula:
\begin{center}
    \textit{Point $p$ is inside rectangle with corners $c_1$ and $c_2$ if and only if:} \\
    $(p.x > c_1.x) \land (p.x < c_2.x) \land (p.y > c_1.y) \land (p.y < c_2.y)$
\end{center}

If the rectangle is defined by a top left corner $c$, width $w$, and height
$h$, the equation can be modified to:

\begin{center}
    \textit{Point $p$ is inside rectangle with top left corner $c$, width $w$ and height $h$ if and only if:} \\
    $(p.x > c.x) \land (p.x < c.x + w) \land (p.y > c.y) \land (p.y < c.y + h)$
\end{center}
When broken down, the formula is evaluating four conditions:
\begin{multicols}{2}
    \begin{enumerate}
        \item The point's x-coordinate is to the right of the left side of the rectangle.
              \begin{equation*}
                  \begin{aligned}
                      p.x & > c_1.x \\
                      p.x & > c.x
                  \end{aligned}
              \end{equation*}

        \item The point's x-coordinate is to the left of the right side of the rectangle.
              \begin{equation*}
                  \begin{aligned}
                      p.x & < c_2.x   \\
                      p.x & < c.x + w
                  \end{aligned}
              \end{equation*}
    \end{enumerate}
\end{multicols}

\begin{multicols}{2}
    \begin{enumerate}
        \item[3.]The point's y-coordinate is above the bottom side of the rectangle.
        \begin{equation*}
            \begin{aligned}
                p.y & > c_1.y \\
                p.y & > c.y
            \end{aligned}
        \end{equation*}

        \item[4.] The point's y-coordinate is below the top side of the rectangle.
            \begin{equation*}
                \begin{aligned}
                    p.y & < c_2.y   \\
                    p.y & < c.y + h
                \end{aligned}
            \end{equation*}
    \end{enumerate}
\end{multicols}
\newpage
\begin{mdframed}[linecolor=black!30!white,linewidth=.5pt,extratopheight=1em]
    \begin{lstlisting}[language=C++, aboveskip=3mm,
        belowskip=3mm,
        showstringspaces=false,
        columns=flexible,
        basicstyle={\small\ttfamily},
        numbers=left,
        numberstyle=\tiny\color{gray},
        keywordstyle=\color{blue},
        commentstyle=\color{dkgreen},
        stringstyle=\color{mauve},
        breaklines=true,
        breakatwhitespace=true,
        tabsize=3,
        xleftmargin=1em]
#include "Vec2.h"
#include <iostream>

struct AABB {
    Vec2 topLeft;
    float width;
    float height;
};

bool pointInsideAABB(const Vec2 &p, const AABB &aabb) {
    const bool inside = p.x > aabb.topLeft.x &&
                        p.x < aabb.topLeft.x + aabb.width &&
                        p.y > aabb.topLeft.y &&
                        p.y < aabb.topLeft.y + aabb.height;

    return inside;
}
\end{lstlisting}

\end{mdframed}
\begin{center}
    \textbf{Listing 2:} \textit{Point Inside AABB in C++}
\end{center}

\newpage
\subsubsection{AABB Intersection}

Determining if two AABBs intersect is a relatively simple task. Given two
AABBs, one may be inclined to check for collision using the point inside AABB
method. However, this is not the most efficient method, as it requires checking
all four corners of one rectangle against the other rectangle. Instead, we can
use an algorithm that detects both horizontal and vertical overlap.

Given two AABBs with top left corners $c_1$ and $c_2$, we can determine if they
overlap horizontally by checking if the right side of the first rectangle is to
the right of the left side of the second rectangle and vice versa. This is done
by the following formula:

\begin{equation}
    \begin{aligned}
         & \textit{Rectangles overlap horizontally if and only if:} \\
         & (c_1.x < c_2.x + c_2.w) \land (c_1.x + c_1.w > c_2.x)
    \end{aligned}
\end{equation}

In a similar manner, we can determine if the rectangles overlap vertically by
checking if the top side of the first rectangle is above the bottom side of the
second rectangle and vice versa. This is done by the following formula:

\begin{equation}
    \begin{aligned}
         & \textit{Rectangles overlap vertically if and only if:} \\
         & (c_1.y < c_2.y + c_2.h) \land (c_1.y + c_1.h > c_2.y)
    \end{aligned}
\end{equation}

Put all together, the AABBs overlap if and only if they overlap both
horizontally and vertically. This is done by the following formula:

\begin{equation}
    % \begin{aligned}
    %      & [(c_1.x < c_2.x + c_2.w) \land (c_1.x + c_1.w > c_2.x)]      \\
    %      & \land[(c_1.y < c_2.y + c_2.h) \land (c_1.y + c_1.h > c_2.y)] \\
    % \end{aligned}
    \begin{aligned}
         & \hspace{1.1em} (c_1.x < c_2.x + c_2.w) \\
         & \land (c_1.x + c_1.w > c_2.x)          \\
         & \land (c_1.y < c_2.y + c_2.h)          \\
         & \land (c_1.y + c_1.h > c_2.y)
    \end{aligned}
\end{equation}

Example of AABB intersection:
\begin{center}
    \begin{tikzpicture}
        \begin{scope}[yscale=-1, yshift=-5cm, xshift=5cm, scale=0.4]

            \drawaxesgrid{15}{20}

            % a point at the origin (0, 0) 
            \filldraw [black] (0, 0) circle (5pt) {};

            % First rectangle
            \draw [black, thick] (3, 3) rectangle (8, 10);
            \draw[black, thick, -] (3, 3) -- (8, 3) node[midway, below] {$w_1$};
            \draw[black, thick, -] (3, 3) -- (3, 10) node[midway, left] {$h_1$};
            % a point at the top left corner of the first rectangle

            \filldraw [black] (3, 3) circle (4pt) node[anchor=north east] {$c_1$};
            % Second rectangle
            \draw [black, thick] (7, 6) rectangle (12, 16);
            \draw[black, thick, -] (7, 6) -- (12, 6) node[midway, below] {$w_2$};
            \draw[black, thick, -] (7, 6) -- (7, 16) node[midway, left]
            {$h_2$};
            % a point at the top left corner of the second rectangle
            \filldraw [black] (7, 6) circle (4pt) node[anchor=north east] {$c_2$};

        \end{scope}
    \end{tikzpicture}
\end{center}

\begin{center}
    \textbf{Figure 1:} \textit{AABB Intersection Example}

\end{center}

It is important to note that the above formula can only check whether or nor
not two AABBs intersect. It does not provide information on how much they
intersect. To determine the overlap, we can use a calculation that takes a
center point and the width and height of the bounding box. This is done as
follows:

Given two AABBs with centers $c_1$ and $c_2$, widths $w_1$ and $w_2$, and
heights $h_1$ and $h_2$,

\begin{equation}
    \begin{aligned}
        \Delta                        & = \left\{ \left| c_1.x - c_2.x \right| , \left| c_1.y - c_2.y \right| \right\}                                                                                     \\
        O                             & = \left\{ \left[ \left( \frac{w_1}{2} + \frac{w_2}{2} \right) - \Delta_x \right] , \left[ \left( \frac{h_1}{2} + \frac{h_2}{2} \right) - \Delta_y \right] \right\} \\
        ( O_x > 0 ) \land ( O_y > 0 ) & \rightarrow \text{AABBs intersect}
    \end{aligned}
\end{equation}

In this formula, the vector $\Delta$ represents the absolute difference between
the center coordinates of the two AABBs along the $x$ and $y$ axes.

The vector $O$ represents the overlap between the two AABBs along the $x$ and
$y$ axes. The overlap along each axis is calculated by subtracting the
difference between the centers from the sum of the half-widths (for the $x$
axis) or half heights (for the $y$ axis) of the two AABBs. Here is an
implementation of the AABB intersection algorithm in C++:

\begin{mdframed}[linecolor=black!30!white,linewidth=.5pt,extratopheight=1em]
    \begin{lstlisting}[language=C++, aboveskip=3mm,
        belowskip=3mm,
        showstringspaces=false,
        columns=flexible,
        basicstyle={\small\ttfamily},
        numbers=left,
        numberstyle=\tiny\color{gray},
        keywordstyle=\color{blue},
        commentstyle=\color{dkgreen},
        stringstyle=\color{mauve},
        breaklines=true,
        breakatwhitespace=true,
        tabsize=3,
        xleftmargin=1em]

#include "Vec2.h"
#include <iostream>

struct AABB {
    Vec2 center;
    float width;
    float height;
};

bool checkAABBIntersection(const AABB &a, const AABB &b) {
    const Vec2 delta = {
        std::abs(a.center.x - b.center.x), 
        std::abs(a.center.y - b.center.y)
    };

    const Vec2 overlap = {
        (a.width / 2 + b.width / 2) - delta.x,
        (a.height / 2 + b.height / 2) - delta.y
    };
    
    const bool AABBIntersects = overlap.x > 0 && overlap.y > 0;

    return AABBIntersects;
}

\end{lstlisting}
\end{mdframed}

% \begin{mdframed}[linecolor=black!30!white,linewidth=.5pt,extratopheight=1em]
%     \begin{lstlisting}[language=C++, aboveskip=3mm,
%         belowskip=3mm,
%         showstringspaces=false,
%         columns=flexible,
%         basicstyle={\small\ttfamily},
%         numbers=left,
%         numberstyle=\tiny\color{gray},
%         keywordstyle=\color{blue},
%         commentstyle=\color{dkgreen},
%         stringstyle=\color{mauve},
%         breaklines=true,
%         breakatwhitespace=true,
%         tabsize=3,
%         xleftmargin=1em]
% #include "Vec2.h"
% class CTransform : public Component {
%     public :
%         Vec2 position = {0, 0};
%         Vec2 previousPosition = {0, 0};
%         Vec2 scale = {1.0, 1.0};
%         float angle = 0;
% };

% class CBoundingBox : public Component {
%     public :
%         Vec2 size;
%         Vec2 halfSize;
%         CBoundingBox(const Vec2 &size) : size(size), halfSize(size / 2) {}
% };

%         \end{lstlisting}
% \end{mdframed}

\newpage
